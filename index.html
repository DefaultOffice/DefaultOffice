<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Default Office</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%23000000'/></svg>">
    <script defer src="https://cdn.vercel-insights.com/v1/script.debug.js"></script>
    <style>
        @font-face {
            font-family: 'Suisse Intl';
            src: url('./SuisseIntl-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Suisse Intl';
            src: url('./SuisseIntl-Light.otf') format('opentype');
            font-weight: 300;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Text selection styling */
        ::selection {
            background-color: black;
            color: white;
        }

        ::-moz-selection {
            background-color: black;
            color: white;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            background: white;
            cursor: none;
            font-family: 'Suisse Intl', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #grid-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
        }

        .grid-square {
            position: absolute;
            background: black;
            transition: none;
            border: none;
            outline: none;
        }

        .grid-hover-indicator {
            position: absolute;
            border: 2px solid #ef4444;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
        }

        /* Custom cursor */
        .custom-cursor {
            position: fixed;
            width: 8px;
            height: 8px;
            background: black;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            mix-blend-mode: difference;
            transition: transform 0.1s ease;
            opacity: 0;
        }

        /* Hide scrollbars */
        ::-webkit-scrollbar {
            display: none;
        }
        
        body {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* Background text - on top but black with hotspot */
        .background-text {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 517px;
            font-size: 16px;
            line-height: 1.3;
            color: black;
            z-index: 50;
            pointer-events: auto;
            user-select: text;
            font-family: 'Suisse Intl', sans-serif;
            font-weight: 400;
            cursor: default;
        }

        .background-text .clients {
            font-weight: 300;
            margin-top: 1em;
            color: black;
        }

        /* Social links - bottom right */
        .social-links {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0;
            z-index: 50;
            text-align: right;
            line-height: 1.3;
        }

        .social-links .copyright {
            font-family: 'Suisse Intl', sans-serif;
            font-weight: 300;
            font-size: 16px;
            line-height: 1.3;
            color: black;
            margin-bottom: 0;
            pointer-events: none;
            user-select: none;
        }

        .social-links .links-row {
            display: flex;
            gap: 20px;
        }

        .social-links a {
            color: black;
            text-decoration: none;
            font-size: 16px;
            line-height: 1.3;
            pointer-events: auto;
            transition: none;
            font-family: 'Suisse Intl', sans-serif;
            font-weight: 300;
            cursor: pointer;
            padding: 8px 12px;
            margin: -8px -12px;
        }

        .social-links a:hover {
            color: #808080;
        }

        /* Logo with invert blend mode - now handles both text fallback and SVG */
        .logo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 700;
            color: white;
            mix-blend-mode: difference;
            z-index: 100;
            pointer-events: none;
            user-select: none;
            letter-spacing: 2px;
        }

        .logo svg {
            width: auto;
            height: 225px;
            fill: white;
            mix-blend-mode: difference;
        }

        /* Large screen adjustments */
        @media (min-width: 1440px) {
            .logo {
                font-size: 58px;
            }

            .logo svg {
                height: 270px;
            }
        }
        @media (max-width: 768px) {
            .background-text {
                width: calc(100vw - 40px);
                bottom: 80px;
                font-size: 13px;
            }

            .social-links {
                bottom: 20px;
                left: 20px;
                right: 20px;
                text-align: left;
                gap: 0;
                flex-direction: row;
                justify-content: space-between;
                align-items: baseline;
            }

            .social-links .copyright {
                margin-bottom: 0;
            }

            .social-links .copyright,
            .social-links a {
                font-size: 13px;
            }

            .social-links .links-row {
                gap: 15px;
                margin-left: auto;
            }

            .logo {
                font-size: 36px;
            }

            .logo svg {
                height: 170px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .background-text {
                font-size: 14px;
            }

            .social-links .copyright,
            .social-links a {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="custom-cursor" id="custom-cursor"></div>
    <div class="background-text">
        Default Office is an industrial design studio based in west London. Directed by Alex D'Souza and Joe Ground, Default Office works across climate and consumer technology, homeware and furniture. Our design ideology and creative services are employed by hardware start-ups and international organisations in the US, Europe and Asia.<br><br><span class="clients">Selected Clients: Lunar Energy, Daylight Computer, JosephJoseph, Unilever, Air-Up, Wild Energy, Opal Camera, Tom Dixon.</span>
    </div>
    <div class="social-links">
        <div class="copyright">Default Office Â© 2025</div>
        <div class="links-row">
            <a href="#" id="email-link">Email</a>
            <a href="https://www.instagram.com/defaultoffice_/" target="_blank">Instagram</a>
            <a href="https://www.linkedin.com/in/alexjosephdsouza/" target="_blank">LinkedIn</a>
        </div>
    </div>
    <div id="grid-canvas"></div>
    <div class="logo" id="logo">Default Office</div>

    <script>
        // Logo loader - checks for logo.svg and loads it if available
        function loadLogo() {
            const logoElement = document.getElementById('logo');
            
            // Try to load logo.svg
            fetch('./logo.svg')
                .then(response => {
                    if (response.ok) {
                        return response.text();
                    }
                    throw new Error('Logo not found');
                })
                .then(svgContent => {
                    // Replace text with SVG
                    logoElement.innerHTML = svgContent;
                })
                .catch(() => {
                    // Keep the default text if SVG fails to load
                    console.log('No logo.svg found, using default text');
                });
        }

        // Load logo on page load
        loadLogo();

        // Email clipboard functionality
        document.getElementById('email-link').addEventListener('click', function(e) {
            e.preventDefault();
            navigator.clipboard.writeText('studio@defaultoffice.com').then(function() {
                console.log('Email copied to clipboard');
                // Optional: Show brief feedback
                const link = e.target;
                const originalText = link.textContent;
                link.textContent = 'Copied';
                setTimeout(() => {
                    link.textContent = originalText;
                }, 2000);
            }).catch(function(err) {
                console.error('Failed to copy email: ', err);
                // Fallback: create temporary input and select
                const tempInput = document.createElement('input');
                tempInput.value = 'studio@defaultoffice.com';
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
            });
        });

        class InteractiveGrid {
            constructor() {
                this.canvasWidth = window.innerWidth;
                this.canvasHeight = window.innerHeight;
                this.isMobile = window.innerWidth <= 768;
                
                // Mobile adjustments
                const baseSquares = this.isMobile ? 21 : 32; // 25% bigger again (fewer squares)
                this.baseSize = (this.canvasWidth / baseSquares) * 4;
                
                // Mobile touch radius is 50% bigger again (total 125% bigger than desktop)
                const radiusMultiplier = this.isMobile ? 1.6875 : 0.75; // 1.6875 = 0.75 * 2.25
                this.hoverRadius = this.baseSize * radiusMultiplier;
                
                this.mousePos = { x: -1000, y: -1000 };
                this.lastTouchPos = { x: -1000, y: -1000 };
                this.isTouch = false;
                this.touchDecayTimer = null;
                this.touchDecaying = false;
                this.touchRevealedSquares = new Set();
                this.touchForceEndTimer = null;
                this.isOverTextHotspot = false;
                this.textHotspotSquares = new Set();
                this.textHotspotClearTimer = null;
                this.isCurrentlyTouchingText = false;
                this.touchTextTimer = null;
                this.squares = [];
                this.flickeringSquares = new Set();
                this.timers = [];
                this.hoverIndicator = null;
                this.customCursor = null;
                this.hasUserInteracted = false;
                
                this.canvas = document.getElementById('grid-canvas');
                this.customCursor = document.getElementById('custom-cursor');
                
                this.initializeGrid();
                this.setupEventListeners();
                this.startFlickering();
                this.handleResize();
            }

            initializeGrid() {
                let y = 0;
                let squareIndex = 0;
                
                while (y < this.canvasHeight) {
                    let x = 0;
                    
                    while (x < this.canvasWidth) {
                        const rand = Math.random();
                        let sizeMultiplier;
                        if (rand < 0.33) sizeMultiplier = 1;        // Large
                        else if (rand < 0.66) sizeMultiplier = 0.5; // Medium
                        else sizeMultiplier = 0.25;                // Small
                        
                        const squareSize = sizeMultiplier * this.baseSize;
                        const width = Math.min(squareSize, this.canvasWidth - x);
                        const height = Math.min(squareSize, this.canvasHeight - y);
                        
                        const squareData = {
                            x, y, width, height,
                            originalSize: squareSize,
                            sizeMultiplier,
                            index: squareIndex,
                            element: null
                        };
                        
                        // Create DOM element with sub-pixel fix
                        const squareElement = document.createElement('div');
                        squareElement.className = 'grid-square';
                        squareElement.style.width = (width + 0.5) + 'px';
                        squareElement.style.height = (height + 0.5) + 'px';
                        squareElement.style.left = x + 'px';
                        squareElement.style.top = y + 'px';
                        squareElement.style.backgroundColor = 'black';
                        squareElement.style.transform = 'translate3d(0,0,0)';
                        
                        this.canvas.appendChild(squareElement);
                        squareData.element = squareElement;
                        this.squares.push(squareData);
                        
                        x += width;
                        squareIndex++;
                    }
                    y += this.baseSize * 0.25;
                }
                
                // Create hover indicator (hidden)
                this.hoverIndicator = document.createElement('div');
                this.hoverIndicator.className = 'grid-hover-indicator';
                this.hoverIndicator.style.width = (this.hoverRadius * 2) + 'px';
                this.hoverIndicator.style.height = (this.hoverRadius * 2) + 'px';
                this.hoverIndicator.style.display = 'none';
                this.canvas.appendChild(this.hoverIndicator);
            }

            setupEventListeners() {
                // Global mouse move for both cursor and hover effect
                document.addEventListener('mousemove', (e) => {
                    this.mousePos.x = e.clientX;
                    this.mousePos.y = e.clientY;
                    this.updateCursor();
                    this.updateHoverEffect();
                });

                document.addEventListener('mouseenter', () => {
                    this.customCursor.style.opacity = '1';
                });

                document.addEventListener('mouseleave', () => {
                    this.mousePos.x = -1000;
                    this.mousePos.y = -1000;
                    this.customCursor.style.opacity = '0';
                    this.updateHoverEffect();
                });

                // Touch events for mobile
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.markUserInteraction(); // Mark interaction
                    
                    if (e.touches.length > 0) {
                        this.mousePos.x = e.touches[0].clientX;
                        this.mousePos.y = e.touches[0].clientY;
                        this.lastTouchPos.x = e.touches[0].clientX;
                        this.lastTouchPos.y = e.touches[0].clientY;
                        this.isTouch = true;
                        this.updateCursor();
                        this.updateHoverEffect();
                        // Cancel decay when user touches again
                        if (this.touchDecayTimer) {
                            clearTimeout(this.touchDecayTimer);
                        }
                        if (this.touchForceEndTimer) {
                            clearTimeout(this.touchForceEndTimer);
                        }
                        this.touchDecaying = false;
                        this.touchRevealedSquares.clear();
                    }
                });

                this.canvas.addEventListener('touchend', () => {
                    this.markUserInteraction(); // Mark interaction
                    
                    // Keep the effect at the last touch position instead of hiding
                    this.mousePos.x = this.lastTouchPos.x;
                    this.mousePos.y = this.lastTouchPos.y;
                    this.updateHoverEffect();
                    this.startTouchDecay();
                });

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.markUserInteraction(); // Mark interaction
                    
                    if (e.touches.length > 0) {
                        this.mousePos.x = e.touches[0].clientX;
                        this.mousePos.y = e.touches[0].clientY;
                        this.lastTouchPos.x = e.touches[0].clientX;
                        this.lastTouchPos.y = e.touches[0].clientY;
                        this.isTouch = true;
                        this.updateCursor();
                        this.updateHoverEffect();
                        // Cancel decay when user touches again
                        if (this.touchDecayTimer) {
                            clearTimeout(this.touchDecayTimer);
                        }
                        if (this.touchForceEndTimer) {
                            clearTimeout(this.touchForceEndTimer);
                        }
                        this.touchDecaying = false;
                        this.touchRevealedSquares.clear();
                    }
                });

                // Global touch events
                document.addEventListener('touchmove', (e) => {
                    this.markUserInteraction(); // Mark interaction
                    
                    if (e.touches.length > 0) {
                        this.mousePos.x = e.touches[0].clientX;
                        this.mousePos.y = e.touches[0].clientY;
                        this.lastTouchPos.x = e.touches[0].clientX;
                        this.lastTouchPos.y = e.touches[0].clientY;
                        this.isTouch = true;
                        this.updateCursor();
                        this.updateHoverEffect();
                        
                        // Check if touch is over text hotspot area during drag
                        const textElement = document.querySelector('.background-text');
                        if (textElement) {
                            const rect = textElement.getBoundingClientRect();
                            const touchX = e.touches[0].clientX;
                            const touchY = e.touches[0].clientY;
                            
                            if (touchX >= rect.left && touchX <= rect.right && 
                                touchY >= rect.top && touchY <= rect.bottom) {
                                if (!this.isOverTextHotspot) {
                                    this.isOverTextHotspot = true;
                                    // Cancel any ongoing clear process
                                    if (this.textHotspotClearTimer) {
                                        clearTimeout(this.textHotspotClearTimer);
                                    }
                                    this.startTextHotspotEffect();
                                }
                                this.isCurrentlyTouchingText = true;
                                clearTimeout(this.touchTextTimer);
                                this.touchTextTimer = setTimeout(() => {
                                    this.isCurrentlyTouchingText = false;
                                }, 100);
                            } else {
                                // Touch is outside text area - start clearing if we were in hotspot
                                if (this.isOverTextHotspot) {
                                    this.isOverTextHotspot = false;
                                    this.isCurrentlyTouchingText = false;
                                    this.startTextHotspotClear();
                                }
                            }
                        }
                        
                        // Cancel decay when user touches again
                        if (this.touchDecayTimer) {
                            clearTimeout(this.touchDecayTimer);
                        }
                        if (this.touchForceEndTimer) {
                            clearTimeout(this.touchForceEndTimer);
                        }
                        this.touchDecaying = false;
                        this.touchRevealedSquares.clear();
                    }
                });

                document.addEventListener('touchend', () => {
                    this.markUserInteraction(); // Mark interaction
                    
                    // Keep the effect at the last touch position
                    this.mousePos.x = this.lastTouchPos.x;
                    this.mousePos.y = this.lastTouchPos.y;
                    this.updateHoverEffect();
                    this.startTouchDecay();
                });

                // Text hotspot events - works on both desktop and mobile
                const textElement = document.querySelector('.background-text');
                if (textElement) {
                    // Desktop mouse events
                    textElement.addEventListener('mouseenter', () => {
                        this.isOverTextHotspot = true;
                        // Cancel any ongoing clear process
                        if (this.textHotspotClearTimer) {
                            clearTimeout(this.textHotspotClearTimer);
                        }
                        this.startTextHotspotEffect();
                    });
                    
                    textElement.addEventListener('mouseleave', () => {
                        this.isOverTextHotspot = false;
                        this.startTextHotspotClear();
                    });

                    // Mobile touch events for text hotspot
                    textElement.addEventListener('touchstart', (e) => {
                        // Don't prevent default here - we want text selection to work
                        this.isOverTextHotspot = true;
                        // Cancel any ongoing clear process
                        if (this.textHotspotClearTimer) {
                            clearTimeout(this.textHotspotClearTimer);
                        }
                        this.startTextHotspotEffect();
                    });

                    // Use a longer delay for mobile before clearing
                    textElement.addEventListener('touchend', () => {
                        setTimeout(() => {
                            if (!this.isCurrentlyTouchingText) {
                                this.isOverTextHotspot = false;
                                this.startTextHotspotClear();
                            }
                        }, 3000); // 3 second delay before starting to clear
                    });

                    // Track if user is actively touching the text area
                    textElement.addEventListener('touchmove', (e) => {
                        this.isCurrentlyTouchingText = true;
                        // Reset after a short delay
                        clearTimeout(this.touchTextTimer);
                        this.touchTextTimer = setTimeout(() => {
                            this.isCurrentlyTouchingText = false;
                        }, 100);
                    });
                }
            }

            handleResize() {
                window.addEventListener('resize', () => {
                    // Clear existing grid
                    this.canvas.innerHTML = '';
                    this.squares = [];
                    this.flickeringSquares.clear();
                    this.timers.forEach(timer => clearTimeout(timer));
                    this.timers = [];
                    
                    // Recalculate dimensions
                    this.canvasWidth = window.innerWidth;
                    this.canvasHeight = window.innerHeight;
                    this.isMobile = window.innerWidth <= 768;
                    
                    // Mobile adjustments
                    const baseSquares = this.isMobile ? 21 : 32; // 25% bigger again (fewer squares)
                    this.baseSize = (this.canvasWidth / baseSquares) * 4;
                    
                    // Mobile touch radius is 50% bigger again (total 125% bigger than desktop)
                    const radiusMultiplier = this.isMobile ? 1.6875 : 0.75; // 1.6875 = 0.75 * 2.25
                    this.hoverRadius = this.baseSize * radiusMultiplier;
                    
                    // Reinitialize
                    this.initializeGrid();
                    this.startFlickering();
                });
            }

            startTextHotspotEffect() {
                // Find all squares in the text area
                const textAreaSquares = [];
                this.squares.forEach((square, index) => {
                    if (this.isSquareInTextHotspot(square)) {
                        textAreaSquares.push(index);
                    }
                });
                
                // Randomly activate squares over time with higher probability
                const activateRandomSquares = () => {
                    if (!this.isOverTextHotspot) return;
                    
                    textAreaSquares.forEach(index => {
                        // Only check squares that aren't already revealed
                        if (!this.textHotspotSquares.has(index)) {
                            // 20% chance per check to turn transparent and stay transparent
                            if (Math.random() < 0.2) {
                                this.textHotspotSquares.add(index);
                            }
                        }
                        // Once a square is revealed, it stays revealed while hovering
                    });
                    
                    this.updateHoverEffect();
                    
                    // Continue the effect while hovering
                    if (this.isOverTextHotspot) {
                        setTimeout(activateRandomSquares, 200); // Check every 200ms
                    }
                };
                
                activateRandomSquares();
            }

            startTextHotspotClear() {
                // Gradually clear squares over time
                const clearRandomSquares = () => {
                    if (this.isOverTextHotspot || this.textHotspotSquares.size === 0) {
                        return; // Stop clearing if mouse re-enters or all squares are cleared
                    }
                    
                    // 70% chance per check to clear a random square (much more aggressive)
                    if (Math.random() < 0.7) {
                        const revealedArray = Array.from(this.textHotspotSquares);
                        if (revealedArray.length > 0) {
                            const randomIndex = revealedArray[Math.floor(Math.random() * revealedArray.length)];
                            this.textHotspotSquares.delete(randomIndex);
                            this.updateHoverEffect();
                        }
                    }
                    
                    // Continue clearing every 80-150ms (much faster)
                    if (this.textHotspotSquares.size > 0 && !this.isOverTextHotspot) {
                        this.textHotspotClearTimer = setTimeout(clearRandomSquares, Math.random() * 70 + 80);
                    }
                };
                
                clearRandomSquares();
            }

            isSquareInTextHotspot(square) {
                // Increase hotspot size by 20% on mobile
                const sizeMultiplier = this.isMobile ? 1.2 : 1.0;
                const baseWidth = 517 * sizeMultiplier;
                const baseHeight = 200 * sizeMultiplier;
                
                // Center the larger hotspot around the original area
                const extraWidth = this.isMobile ? (baseWidth - 517) / 2 : 0;
                const extraHeight = this.isMobile ? (baseHeight - 200) / 2 : 0;
                
                const textBounds = {
                    left: 20 - extraWidth,
                    top: window.innerHeight - 20 - 200 - extraHeight,
                    right: 20 + baseWidth - extraWidth,
                    bottom: window.innerHeight - 20 + extraHeight
                };
                
                return (square.x < textBounds.right && 
                        square.x + square.width > textBounds.left &&
                        square.y < textBounds.bottom && 
                        square.y + square.height > textBounds.top);
            }

            markUserInteraction() {
                // On mobile, if this is the first interaction, activate text hotspot
                if (this.isMobile && !this.hasUserInteracted) {
                    this.startTextHotspotEffect();
                }
                
                this.hasUserInteracted = true;
            }

            startTouchDecay() {
                // Clear any existing timers
                if (this.touchDecayTimer) {
                    clearTimeout(this.touchDecayTimer);
                }
                if (this.touchForceEndTimer) {
                    clearTimeout(this.touchForceEndTimer);
                }
                
                // If over text hotspot, don't start decay - let hotspot handle it
                if (this.isOverTextHotspot) {
                    return;
                }
                
                // Reset decay state
                this.touchDecaying = false;
                
                // Identify squares currently revealed by touch
                this.touchRevealedSquares.clear();
                this.squares.forEach((square, index) => {
                    if (this.isSquareInRadius(square)) {
                        this.touchRevealedSquares.add(index);
                    }
                });
                
                // Start immediate decay for regular touch areas (not text hotspot)
                this.touchDecaying = true;
                this.randomTouchDecay();
                
                // Force complete end after 15 seconds (total)
                this.touchForceEndTimer = setTimeout(() => {
                    this.forceEndTouchReveal();
                }, 15000);
            }

            forceEndTouchReveal() {
                // Clear all timers
                if (this.touchDecayTimer) {
                    clearTimeout(this.touchDecayTimer);
                }
                if (this.touchForceEndTimer) {
                    clearTimeout(this.touchForceEndTimer);
                }
                
                // Clear all touch revealed squares
                this.touchRevealedSquares.clear();
                this.touchDecaying = false;
                this.isTouch = false;
                this.mousePos.x = -1000;
                this.mousePos.y = -1000;
                this.updateHoverEffect();
            }

            randomTouchDecay() {
                if (!this.touchDecaying || this.touchRevealedSquares.size === 0) {
                    this.isTouch = false;
                    this.mousePos.x = -1000;
                    this.mousePos.y = -1000;
                    this.updateHoverEffect();
                    return;
                }
                
                // Higher chance to turn off a square (50% chance per check - increased rate)
                if (Math.random() < 0.5) {
                    // Pick a random revealed square to turn off
                    const revealedArray = Array.from(this.touchRevealedSquares);
                    const randomIndex = revealedArray[Math.floor(Math.random() * revealedArray.length)];
                    this.touchRevealedSquares.delete(randomIndex);
                    
                    // Update the display
                    this.updateHoverEffect();
                }
                
                // Continue checking every 150-350ms (faster intervals)
                setTimeout(() => this.randomTouchDecay(), Math.random() * 200 + 150);
            }

            updateCursor() {
                if (this.customCursor && this.mousePos.x > -500) {
                    this.customCursor.style.left = (this.mousePos.x - 4) + 'px';
                    this.customCursor.style.top = (this.mousePos.y - 4) + 'px';
                }
            }

            updateHoverEffect() {
                // Update hover indicator position (hidden)
                if (this.mousePos.x > 0) {
                    this.hoverIndicator.style.display = 'block';
                    this.hoverIndicator.style.left = (this.mousePos.x - this.hoverRadius) + 'px';
                    this.hoverIndicator.style.top = (this.mousePos.y - this.hoverRadius) + 'px';
                } else {
                    this.hoverIndicator.style.display = 'none';
                }
                
                // Update square colors with text hotspot logic
                this.squares.forEach((square, index) => {
                    const isInRadius = this.isSquareInRadius(square);
                    const isFlickering = this.flickeringSquares.has(square.index);
                    const isTouchRevealed = this.touchRevealedSquares.has(index);
                    const isTextHotspotActive = this.textHotspotSquares.has(index);
                    
                    if (isInRadius || isFlickering || isTouchRevealed || isTextHotspotActive) {
                        square.element.style.backgroundColor = 'transparent';
                    } else {
                        square.element.style.backgroundColor = 'black';
                    }
                });
            }

            isSquareInRadius(square) {
                const squareCenterX = square.x + square.width / 2;
                const squareCenterY = square.y + square.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(this.mousePos.x - squareCenterX, 2) + 
                    Math.pow(this.mousePos.y - squareCenterY, 2)
                );
                
                return distance <= this.hoverRadius;
            }

            startFlickering() {
                this.squares.forEach((square, index) => {
                    const randomDelay = Math.random() * 5000 + 1000; // 1-6 second initial delay
                    
                    const flicker = () => {
                        if (Math.random() < 0.15) { // 15% chance to toggle
                            if (this.flickeringSquares.has(index)) {
                                this.flickeringSquares.delete(index);
                            } else {
                                this.flickeringSquares.add(index);
                            }
                            this.updateHoverEffect();
                        }
                        
                        // Set next random flicker time
                        const nextDelay = Math.random() * 4000 + 500; // 0.5-4.5 second intervals
                        this.timers[index] = setTimeout(flicker, nextDelay);
                    };
                    
                    this.timers[index] = setTimeout(flicker, randomDelay);
                });
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new InteractiveGrid();
        });

        // Prevent context menu on right click
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Prevent scrolling on mobile
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

        // Prevent zoom on double tap (iOS Safari)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
